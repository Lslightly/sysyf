package main

import (
	"errors"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"strings"
)

var pkgFlag = flag.String("package", "", "prefix of generated code(<package>_sum.go, <package>_iface.go). If it's empty, the generated code will be sum.go, iface.go")

func init() {
	flag.Usage = func() {
		flag.PrintDefaults()
	}
}

type Spec struct {
	exportedName string // exported interface
	internalName string // internal sum interface
	types        []string
}

func NewSpec(specStr string) Spec {
	elems := strings.Split(specStr, ":")
	if len(elems) != 3 {
		panic("invalid spec: " + specStr)
	}
	exportedName := strings.TrimSpace(elems[0])
	internalName := strings.TrimSpace(elems[1])
	types := strings.Split(elems[2], "|")
	if len(types) <= 1 {
		panic("invalid spec: " + specStr)
	}
	spec := Spec{
		exportedName: exportedName,
		internalName: internalName,
		types:        make([]string, 0, len(types)),
	}
	for _, ty := range types {
		ty = strings.TrimSpace(ty)
		spec.types = append(spec.types, ty)
	}
	return spec
}

const internalIfaceFmt = `
type %s interface {
	%s() // not exported dummy method
}`
const structFmt = `func (%s) %s() {}`
const exportedIfaceFmt = `
type %s interface {
	%s
}
`

const sumFmt = `// Code generated by sum_generator DO NOT EDIT.
package %s
%s`
const ifaceFmt = `package %s
%s`

func (s *Spec) NewSum() string {
	defs := make([]string, 0, len(s.types)+1)
	defs = append(defs, fmt.Sprintf(internalIfaceFmt, s.internalName, s.internalName))
	for _, ty := range s.types {
		defs = append(defs, fmt.Sprintf(structFmt, ty, s.internalName))
	}
	return strings.Join(defs, "\n")
}
func (s *Spec) NewIface() string {
	return fmt.Sprintf(exportedIfaceFmt, s.exportedName, s.internalName)
}
func isFileExist(path string) bool {
	_, err := os.Stat(path)
	return !errors.Is(err, fs.ErrNotExist)
}

func getSpecStrs(file string) (res []string) {
	bs, err := os.ReadFile(file)
	if err != nil {
		panic(err)
	}
	str := string(bs)
	lines := strings.Split(str, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		} else {
			res = append(res, line)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() != 1 {
		flag.Usage()
		os.Exit(1)
	}
	pkg := *pkgFlag
	specStrs := getSpecStrs(flag.Arg(0))

	sumDefs := make([]string, 0, len(specStrs))
	ifaceDefs := make([]string, 0, len(specStrs))
	for _, specStr := range specStrs {
		spec := NewSpec(specStr)
		sumDefs = append(sumDefs, spec.NewSum())
		ifaceDefs = append(ifaceDefs, spec.NewIface())
	}
	sumStr := fmt.Sprintf(sumFmt, pkg, strings.Join(sumDefs, "\n"))
	ifaceStr := fmt.Sprintf(ifaceFmt, pkg, strings.Join(ifaceDefs, "\n"))
	f, err := os.Create("sum.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	fmt.Fprint(f, sumStr)
	if !isFileExist("iface.go") {
		f, err = os.Create("iface.go")
		if err != nil {
			panic(err)
		}
		defer f.Close()
		fmt.Fprint(f, ifaceStr)
	}
}
